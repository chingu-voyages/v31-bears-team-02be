import bcrypt from 'bcryptjs';
import knex from 'knex';
import jwt from 'jsonwebtoken';
import xss from 'xss';
import config from '../config';

// User data access object (used to abstract interface w/ db)
class UserDAO {
	usersTable = 'users';
	secret = config.JWT_SECRET;
	REGEX_UPPER_LOWER_NUMBER_SPECIAL = /(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&])[\S]+/;
	/**
	 * Sanitize and parse database values before sending them to client
	 * @param {{user_id: number, username: string, date_created: string}} user - User object from database 
	 * @returns {{user_id: number, username: string, date_created: string}} User object formatted for transfer
	 */
	serializeUser = (user) => ({
		user_id: user.user_id,
		username: xss(user.username),
		date_created: user.date_created,
	})
	/**
	 * Create new user in DB with given username and password strings
	 * @param {knex} db - knex db connection object
	 * @param {string} username - Username string
	 * @param {string} password - Password string
	 * @returns {Promise<{
	 * user_id: number, username: string, password: string, date_created: string,
	 * }>} Promise that resolves to the created user data form db
	 */
	async createUser(db, username, password) {
		// destructure user after creating new user
		const [user] = await db('user')
			.insert({ // knex syntax:
				username,
				password
			})
			.into(this.usersTable)
			.returning('*');

		return user;
	}
	/**
	 * Check if given string is already used for username in users table
	 * @param {knex} db - knex db connection object
	 * @param {string} username - Username string to check against db data
	 * @returns {Promise<boolean>} Promise resolves to true if given string is taken
	 */
	async getByUserName(db, username) {
		const nameInDB = await db(this.usersTable)
			.where({ username })
			.first()
		return nameInDB;
	}
	/**
	 * Validates password string to have between 8 and 72 characters, contains one uppercase, lowercase, number and special character
	 * @param {string} password 
	 * @returns A string describing the requirement that didn't pass or null if no validation problems
	 */
	validatePassword(password) {
		if (password.length < 8) {
			return 'Password must be longer than 8 characters';
		}
		if (password.length > 72) {
			return 'Password be less than 72 characters';
		}
		if (password.startsWith(' ') || password.endsWith(' ')) {
			return 'Password must not start or end with empty spaces';
		}
		if (!this.REGEX_UPPER_LOWER_NUMBER_SPECIAL.test(password)) {
			return 'Password must contain one upper case, lower case, number and special character';
		}
		return null;
	}
	/**
	 * Use bcrypt.hash to generate hash from given password string
	 * @param {string} password password string provided by user
	 * @return {Promise<string>} salt and hash string generated by bcrypt
	 */
	async hashPassword(password) {
		const hash = await bcrypt.hash(password, 12);
		return hash;
	}
	/**
		 * 
		 * @param {string} password - The password string given by user
		 * @param {string} hash - The hash generated by bcrypt and stored in db
		 * @returns Returns promise that resolves to bool wether password is found or not.
		 */
	comparePasswords(password, hash) {
		return bcrypt.compare(password, hash);
	}
	createJWT(subject, payload) {
		return jwt.sign(payload, this.secret, {
			subject,
			algorithm: 'HS256',
		});
	}
	verifyJwt(token) {
		return jwt.verify(token, config.JWT_SECRET, {
			algorithms: ['HS256'],
		});
	}
}

export default new UserDAO();